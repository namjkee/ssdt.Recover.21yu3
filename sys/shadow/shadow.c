/*
	shadow.C
	Author: <your name>
	Last Updated: 2007-07-06

	This framework is generated by EasySYS 0.3.0 Modify
	This template file is copying from QuickSYS 0.3.0 written by Chunhua Liu
	//=============================================
	Modified by PLK_XiaoWei[0GiNr]
	http://www.0GiNr.com
	//=============================================
*/
//#include "windef.h"  
#include "shadow.h"    
#include "dbghelp.h"
#include "windef.h"  
#include "ntddk.h" 
//#include "LDasm.h" 
//#include "LDasm.c"
#include <stdlib.h>
//=================
#include <ntddk.h>
#include <devioctl.h>

#define IOCTL_SETPROC  (ULONG)CTL_CODE(FILE_DEVICE_UNKNOWN, 0x852, METHOD_NEITHER, FILE_READ_DATA | FILE_WRITE_DATA )

NTSTATUS DisPatchCreateClose(PDEVICE_OBJECT pDriverObj,PIRP pIrp);
NTSTATUS DispatchDeviceControl(IN PDEVICE_OBJECT  DeviceObject,IN PIRP  pIrp);
void DriverUnload(PDRIVER_OBJECT pDriverObj);

typedef struct _tagSSDT {
    PVOID pvSSDTBase;
    PVOID pvServiceCounterTable;
    ULONG ulNumberOfServices;
    PVOID pvParamTableBase;
} SSDT, *PSSDT;

UNICODE_STRING DerName,DerName2;
PDEVICE_OBJECT	pDevObj;

extern PSSDT    KeServiceDescriptorTable;


//StartService时调用
NTSTATUS DriverEntry( IN PDRIVER_OBJECT theDriverObject, IN PUNICODE_STRING theRegistryPath )
{
	
	
	NTSTATUS status=STATUS_SUCCESS;
	
	ULONG i;
	

	for(i= 0;i<IRP_MJ_MAXIMUM_FUNCTION;++i)
		theDriverObject->MajorFunction[i] = DisPatchCreateClose;
	

	theDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]=DispatchDeviceControl;
	__asm
	{
		nop
		mov edi,edi
	}
	theDriverObject->DriverUnload=DriverUnload;
	__asm
	{
		nop
		add eax,-258
		add eax,258
	}
	
	RtlInitUnicodeString(&DerName,L"\\Device\\RESSDT");
	
	status=IoCreateDevice(theDriverObject,0,&DerName,FILE_DEVICE_UNKNOWN,0,FALSE,&pDevObj);
	
	if(!NT_SUCCESS(status))
	{
		
		DbgPrint("IoCreateDevice Fail!");
		return status;
	}
	

	RtlInitUnicodeString(&DerName2,L"\\??\\RESSDTDOS");
	
	status=IoCreateSymbolicLink(&DerName2,&DerName);
	
	if(!NT_SUCCESS(status))
		DbgPrint("IoCreateSymbolicLink fail!");
		

	return status;
}
NTSTATUS DisPatchCreateClose(PDEVICE_OBJECT pDriverObj,PIRP pIrp)
{
	DbgPrint("DisPatchCreate!");
	
	pIrp->IoStatus.Status=STATUS_SUCCESS;
	
	IoCompleteRequest(pIrp,IO_NO_INCREMENT);
	
	return STATUS_SUCCESS;
}
//服务停止时执行
void DriverUnload(PDRIVER_OBJECT pDriverObj)
{
	if(IoDeleteSymbolicLink(&DerName2)!=STATUS_SUCCESS)
		
		DbgPrint("DeleteSymbolicLink Fail!");
	
	IoDeleteDevice(pDriverObj->DeviceObject);
	
}
//DeviceIoControl 时执行 
NTSTATUS DispatchDeviceControl(IN PDEVICE_OBJECT  DeviceObject,IN PIRP  pIrp)
{
	
	NTSTATUS status=STATUS_INVALID_DEVICE_REQUEST;
	
	PIO_STACK_LOCATION pIrpStack=IoGetCurrentIrpStackLocation(pIrp);
	
	ULONG uIoControlCode=pIrpStack->Parameters.DeviceIoControl.IoControlCode;
	PVOID pInputBuffer= pIrpStack->Parameters.DeviceIoControl.Type3InputBuffer;
	PVOID pOutputBuffer=pIrp->UserBuffer;
	ULONG uInsize=pIrpStack->Parameters.DeviceIoControl.InputBufferLength;
	ULONG uOutsize=pIrpStack->Parameters.DeviceIoControl.OutputBufferLength;

	//DbgPrint("DispatchDeviceControl  Code:%X",uIoControlCode);
	switch(uIoControlCode)
	{
		case IOCTL_SETPROC:
		{
			ULONG uIndex = 0;
			PULONG pBase = NULL;
			
			__try
			{
				ProbeForRead( pInputBuffer, sizeof( ULONG ), sizeof( ULONG ) );
				ProbeForWrite( pOutputBuffer, sizeof( ULONG ), sizeof( ULONG ) );
				
			}
			__except( EXCEPTION_EXECUTE_HANDLER )
			{
				status= GetExceptionCode();
				break;
				
			}


			uIndex = *(PULONG)pInputBuffer;
			
			if ( KeServiceDescriptorTable->ulNumberOfServices <= uIndex )
			{
				status= STATUS_INVALID_PARAMETER;
				
				break;
			}
			__asm
			{
				mov edi,edi
				nop
				mov edi,edi
			}
			pBase  = KeServiceDescriptorTable->pvSSDTBase;
			__asm
			{
				mov edi,edi
				nop
				mov edi,edi
			}
			DbgPrint("0x%x 0x%x",uIndex,*((PULONG)pOutputBuffer));
			
			__asm
			{//关中断
            		cli
				mov eax,cr0
				and eax,~0x10000
				mov cr0,eax
			}
			*( pBase + uIndex )=*((PULONG)pOutputBuffer);
			
			__asm
			{//开中断
				mov  eax,cr0
				or   eax,0x10000
				mov  cr0,eax
				sti
			}
			__asm
			{
				mov edi,edi
				nop
				mov edi,edi
				mov edi,edi
			}
			status=STATUS_SUCCESS;
		}
		
		break;
		default:
			break;
	}
	if(status==STATUS_SUCCESS)
		pIrp->IoStatus.Information=uOutsize;
		
	else
		pIrp->IoStatus.Information=0;
		
	
	pIrp->IoStatus.Status=status;
	
	IoCompleteRequest(pIrp,IO_NO_INCREMENT);
	
	
	return status;	
}

//====================
PVOID __stdcall GetModuleHandle(char *SubStr); // idb
FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName); // idb
void __stdcall MapPeFile(int a1, unsigned int a2, void *a3, unsigned int a4);
void __stdcall ProcessRelocs(PVOID a1, PVOID a2);
char __stdcall ProcessImports(unsigned int a1);
PVOID  __stdcall LoadPeFile(PCWSTR   SourceString, unsigned int a2, unsigned int a3);
PVOID __stdcall LoadVirtualDriver(PCWSTR   SourceString);
int __stdcall UnloadVirtualDriver(int *a1);


typedef unsigned long DWORD;
typedef DWORD * PDWORD;
typedef unsigned long ULONG;
typedef unsigned short WORD;
typedef unsigned char BYTE;

typedef NTSTATUS (NTAPI*NTPROC)();

typedef NTPROC* PNTPROC;

#define NTPROC_ sizeof(NTPROC)

typedef struct _SYSTEM_SERVICE_TABLE

{

       PNTPROC  ServiceTable;   // array of entry points

       PDWORD  CounterTable;   // array of usage counters

       DWORD   ServiceLimit;    // number of table entries

       PBYTE    ArgumentTable;  // array of byte counts

}

SYSTEM_SERVICE_TABLE,

*PSYSTEM_SERVICE_TABLE,

**PPSYSTEM_SERVICE_TABLE;

//-----------------------------------------------------------------------------------------------------------

typedef struct _SERVICE_DESCRIPTOR_TABLE

{

       SYSTEM_SERVICE_TABLE ntoskrnl;  // ntoskrnl.exe ( native api )

    SYSTEM_SERVICE_TABLE win32k;    // win32k.sys (gdi/user support)

       SYSTEM_SERVICE_TABLE Table3;    // not used

       SYSTEM_SERVICE_TABLE Table4;    // not used

}

SYSTEM_DESCRIPTOR_TABLE,

*PSYSTEM_DESCRIPTOR_TABLE,

**PPSYSTEM_DESCRIPTOR_TABLE;

//-----------------------------------------------------------------------------------------------------------
typedef enum _SYSTEM_INFORMATION_CLASS {
    SystemBasicInformation,
    SystemProcessorInformation,
    SystemPerformanceInformation,
    SystemTimeOfDayInformation,
    SystemNotImplemented1,
    SystemProcessesAndThreadsInformation,
    SystemCallCounts,
    SystemConfigurationInformation,
    SystemProcessorTimes,
    SystemGlobalFlag,
    SystemNotImplemented2,
    SystemModuleInformation,
    SystemLockInformation,
    SystemNotImplemented3,
    SystemNotImplemented4,
    SystemNotImplemented5,
    SystemHandleInformation,
    SystemObjectInformation,
    SystemPagefileInformation,
    SystemInstructionEmulationCounts,
    SystemInvalidInfoClass1,
    SystemCacheInformation,
    SystemPoolTagInformation,
    SystemProcessorStatistics,
    SystemDpcInformation,
    SystemNotImplemented6,
    SystemLoadImage,
    SystemUnloadImage,
    SystemTimeAdjustment,
    SystemNotImplemented7,
    SystemNotImplemented8,
    SystemNotImplemented9,
    SystemCrashDumpInformation,
    SystemExceptionInformation,
    SystemCrashDumpStateInformation,
    SystemKernelDebuggerInformation,
    SystemContextSwitchInformation,
    SystemRegistryQuotaInformation,
    SystemLoadAndCallImage,
    SystemPrioritySeparation,
    SystemNotImplemented10,
    SystemNotImplemented11,
    SystemInvalidInfoClass2,
    SystemInvalidInfoClass3,
    SystemTimeZoneInformation,
    SystemLookasideInformation,
    SystemSetTimeSlipEvent,
    SystemCreateSession,
    SystemDeleteSession,
    SystemInvalidInfoClass4,
    SystemRangeStartInformation,
    SystemVerifierInformation,
    SystemAddVerifier,
    SystemSessionProcessesInformation
} SYSTEM_INFORMATION_CLASS;
typedef struct _SYSTEM_HANDLE_INFORMATION { 
ULONG ProcessId; 
UCHAR ObjectTypeNumber; 
UCHAR Flags; 
USHORT Handle; 
PVOID Object; 
ACCESS_MASK GrantedAccess; 
} SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION; 

typedef struct _SYSTEM_HANDLE_INFORMATION_EX { 
ULONG NumberOfHandles; 
SYSTEM_HANDLE_INFORMATION Information[1]; 
} SYSTEM_HANDLE_INFORMATION_EX, *PSYSTEM_HANDLE_INFORMATION_EX; 



typedef struct _SYSTEM_THREAD_INFORMATION {
	LARGE_INTEGER KernelTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER CreateTime;
	ULONG WaitTime;
	PVOID StartAddress;
	CLIENT_ID ClientId;
	KPRIORITY Priority;
	KPRIORITY BasePriority;
	ULONG ContextSwitchCount;
	LONG State;
	LONG WaitReason;
} SYSTEM_THREAD_INFORMATION, * PSYSTEM_THREAD_INFORMATION;

typedef struct _SYSTEM_PROCESS_INFORMATION {
	ULONG NextEntryDelta;
	ULONG ThreadCount;
	ULONG Reserved1[6];
	LARGE_INTEGER CreateTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER KernelTime;
	UNICODE_STRING ProcessName;
	KPRIORITY BasePriority;
	ULONG ProcessId;
	ULONG InheritedFromProcessId;
	ULONG HandleCount;
	ULONG Reserved2[2];
	VM_COUNTERS VmCounters;
	IO_COUNTERS IoCounters;
	SYSTEM_THREAD_INFORMATION Threads[1];
} SYSTEM_PROCESS_INFORMATION, * PSYSTEM_PROCESS_INFORMATION;
char ProcessName[256]; // define process name container

typedef ULONG DWORD;
typedef VOID* LPVOID;
#define STATUS_INFO_LENGTH_MISMATCH ((NTSTATUS)0xC0000004L)


typedef struct tagSYSTEM_MODULE_INFORMATION {
    ULONG Reserved[2];
    PVOID Base;
    ULONG Size;
    ULONG Flags;
    USHORT Index;
    USHORT Unknown;
    USHORT LoadCount;
    USHORT ModuleNameOffset;
    CHAR ImageName[256];
} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;

#define IMAGE_DOS_SIGNATURE        0x5A4D      // MZ
#define IMAGE_NT_SIGNATURE      0x50450000  // PE00
#define IMAGE_NT_SIGNATURE1        0x00004550    // 00EP

typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header
    WORD   e_magic;                     // Magic number
    WORD   e_cblp;                      // Bytes on last page of file
    WORD   e_cp;                        // Pages in file
    WORD   e_crlc;                      // Relocations
    WORD   e_cparhdr;                   // Size of header in paragraphs
    WORD   e_minalloc;                  // Minimum extra paragraphs needed
    WORD   e_maxalloc;                  // Maximum extra paragraphs needed
    WORD   e_ss;                        // Initial (relative) SS value
    WORD   e_sp;                        // Initial SP value
    WORD   e_csum;                      // Checksum
    WORD   e_ip;                        // Initial IP value
    WORD   e_cs;                        // Initial (relative) CS value
    WORD   e_lfarlc;                    // File address of relocation table
    WORD   e_ovno;                      // Overlay number
    WORD   e_res[4];                    // Reserved words
    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
    WORD   e_oeminfo;                   // OEM information; e_oemid specific
    WORD   e_res2[10];                  // Reserved words
    LONG   e_lfanew;                    // File address of new exe header
  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;


typedef struct _IMAGE_FILE_HEADER {
    WORD    Machine;
    WORD    NumberOfSections;
    DWORD   TimeDateStamp;
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
    WORD    SizeOfOptionalHeader;
    WORD    Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;

typedef struct _IMAGE_DATA_DIRECTORY {
    DWORD   VirtualAddress;
    DWORD   Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16

//
// Optional header format.
//

typedef struct _IMAGE_OPTIONAL_HEADER {
    //
    // Standard fields.
    //

    WORD    Magic;
    BYTE    MajorLinkerVersion;
    BYTE    MinorLinkerVersion;
    DWORD   SizeOfCode;
    DWORD   SizeOfInitializedData;
    DWORD   SizeOfUninitializedData;
    DWORD   AddressOfEntryPoint;
    DWORD   BaseOfCode;
    DWORD   BaseOfData;

    //
    // NT additional fields.
    //

    DWORD   ImageBase;
    DWORD   SectionAlignment;
    DWORD   FileAlignment;
    WORD    MajorOperatingSystemVersion;
    WORD    MinorOperatingSystemVersion;
    WORD    MajorImageVersion;
    WORD    MinorImageVersion;
    WORD    MajorSubsystemVersion;
    WORD    MinorSubsystemVersion;
    DWORD   Win32VersionValue;
    DWORD   SizeOfImage;
    DWORD   SizeOfHeaders;
    DWORD   CheckSum;
    WORD    Subsystem;
    WORD    DllCharacteristics;
    DWORD   SizeOfStackReserve;
    DWORD   SizeOfStackCommit;
    DWORD   SizeOfHeapReserve;
    DWORD   SizeOfHeapCommit;
    DWORD   LoaderFlags;
    DWORD   NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;

typedef struct _IMAGE_NT_HEADERS {
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER32 OptionalHeader;
} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;

typedef IMAGE_NT_HEADERS32                  IMAGE_NT_HEADERS;
typedef PIMAGE_NT_HEADERS32                 PIMAGE_NT_HEADERS;

//
// Section header format.
//

#define IMAGE_SIZEOF_SHORT_NAME              8

typedef struct _IMAGE_SECTION_HEADER {
    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];
    union {
            DWORD   PhysicalAddress;
            DWORD   VirtualSize;
    } Misc;
    DWORD   VirtualAddress;
    DWORD   SizeOfRawData;
    DWORD   PointerToRawData;
    DWORD   PointerToRelocations;
    DWORD   PointerToLinenumbers;
    WORD    NumberOfRelocations;
    WORD    NumberOfLinenumbers;
    DWORD   Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

#define IMAGE_SIZEOF_SECTION_HEADER          40
//
// Export Format
//

typedef struct _IMAGE_EXPORT_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    DWORD   Name;
    DWORD   Base;
    DWORD   NumberOfFunctions;
    DWORD   NumberOfNames;
    DWORD   AddressOfFunctions;     // RVA from base of image
    DWORD   AddressOfNames;         // RVA from base of image
    DWORD   AddressOfNameOrdinals;  // RVA from base of image
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;

#define BASEADDRLEN 10


typedef struct _MODULE_INFO {
    ULONG dwReserved[2];
    ULONG dwBase;
    ULONG dwSize;
    ULONG dwFlags;
    USHORT wIndex;
    USHORT wRank;
    USHORT wLoadCount;
    USHORT NameOffset;
    char cPath[256];
} MODULE_INFO, *PMODULE_INFO, **PPMODULE_INFO;

typedef struct _MODULE_LIST {
    ULONG dwModules;
    MODULE_INFO Modules[1];
} MODULE_LIST, *PMODULE_LIST, **PPMODULE_LIST;

	wchar_t  *ntosName;












typedef enum _OBJECT_INFORMATION_CLASS
{
 ObjectBasicInformation,
 ObjectNameInformation,
 ObjectTypeInformation,
 ObjectTypesInformation,
 ObjectHandleFlagInformation
} OBJECT_INFORMATION_CLASS;

NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySystemInformation(
    ULONG        SystemInformationClass,
    PVOID        SystemInformation,
    ULONG        SystemInformationLength,
    PULONG        ReturnLength
);

NTSYSAPI
NTSTATUS
NTAPI
ZwDuplicateObject(
IN HANDLE SourceProcessHandle,
IN PHANDLE SourceHandle,
IN HANDLE TargetProcessHandle,
OUT PHANDLE TargetHandle,
IN ACCESS_MASK DesiredAccess OPTIONAL,
IN BOOLEAN InheritHandle,
IN ULONG Options );

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryObject( 
IN HANDLE ObjectHandle, 
IN OBJECT_INFORMATION_CLASS ObjectInformationClass, 
OUT PVOID ObjectInformation, 
IN ULONG ObjectInformationLength, 
OUT PULONG ReturnLength OPTIONAL 
); 



HANDLE hKernelFile = 0, hKernelSection = 0;
PVOID pKernel = NULL;
NTSTATUS PsLookupProcessByProcessId( IN ULONG ulProcId, OUT PEPROCESS * pEProcess);
VOID KeAttachProcess ( IN PEPROCESS pEProcess ); 
VOID KeDetachProcess ( VOID ); 

typedef struct _KAPC_STATE
{
  LIST_ENTRY ApcListHead[2];
  PVOID Process;
  BOOLEAN KernelApcInProgress;
  BOOLEAN KernelApcPending;
  BOOLEAN UserApcPending;
} KAPC_STATE, *PKAPC_STATE;

extern
NTKERNELAPI void KeStackAttachProcess(PVOID Process, PKAPC_STATE ApcState);

extern
NTKERNELAPI void KeUnstackDetachProcess(PKAPC_STATE ApcState);

/* 
define structure for the system service table
*/ 
struct SYS_SERVICE_TABLE { 
 void **ServiceTable; 
 unsigned long CounterTable; 
 unsigned long ServiceLimit; 
 void **ArgumentsTable; 
};

SYSTEM_DESCRIPTOR_TABLE KeServiceDescriptorTableShadow;

/* 
Define KeServiceDescriptorTable based on the SST structure 
*/ 
extern struct SYS_SERVICE_TABLE *KeServiceDescriptorTable; 

/*
Declare function GetServiceDescriptorShadowTableAddress() 
*/
//struct SYS_SERVICE_TABLE * GetServiceDescriptorShadowTableAddress (); 
/* 
Declare the KeAddSystemServiceTable. This is just a 
handle to the call function, it will be used by the function 
above to obtain the correct address of the KeServiceDescriptorShadowTable 
*/ 
__declspec(dllimport) KeAddSystemServiceTable (ULONG, ULONG, ULONG, ULONG, ULONG); 

//===========================================
NTSTATUS DriverEntry(PDRIVER_OBJECT pDriverObj, PUNICODE_STRING pRegistryString);
NTSTATUS DispatchCreate(PDEVICE_OBJECT pDevObj, PIRP pIrp);
NTSTATUS DispatchClose(PDEVICE_OBJECT pDevObj, PIRP pIrp);
VOID DriverUnload(PDRIVER_OBJECT pDriverObj);
NTSTATUS DispatchIoctl(PDEVICE_OBJECT pDevObj, PIRP pIrp);
//==========================================

PCHAR MyGetModuleBaseAddress( PCHAR pModuleName )
{
    PSYSTEM_MODULE_INFORMATION    pSysModule;    

    ULONG            uReturn;
    ULONG            uCount;
    PCHAR            pBuffer = NULL;
    PCHAR            pName    = NULL;
    NTSTATUS        status;
    UINT            ui;

    CHAR            szBuffer[BASEADDRLEN];
    PCHAR            pBaseAddress;
    
    status = ZwQuerySystemInformation( SystemModuleInformation, szBuffer, BASEADDRLEN, &uReturn );

    pBuffer = ( PCHAR )ExAllocatePool( NonPagedPool, uReturn );

    if ( pBuffer )
    {
        status = ZwQuerySystemInformation( SystemModuleInformation, pBuffer, uReturn, &uReturn );

        if( status == STATUS_SUCCESS )
        {
            uCount = ( ULONG )*( ( ULONG * )pBuffer );
            pSysModule = ( PSYSTEM_MODULE_INFORMATION )( pBuffer + sizeof( ULONG ) );

            for ( ui = 0; ui < uCount; ui++ )
            {
                pName = strchr( pSysModule->ImageName, '\\' );

                if ( !pName )
                {
                    pName = pSysModule->ImageName;
                }

                else {
                    pName++;
                }

                if( !_stricmp( pName, pModuleName ) )
                {
                    pBaseAddress = ( PCHAR )pSysModule->Base;
                    ExFreePool( pBuffer );
                    return pBaseAddress;
                }

                pSysModule ++;
            }
        }

        ExFreePool( pBuffer );
    }

    return NULL;
}


DWORD FindPeSection( DWORD pModuleBase, PCHAR SectionName )
{
    PIMAGE_DOS_HEADER         pDosHdr;
    PIMAGE_NT_HEADERS         pNtHdr;
    PIMAGE_SECTION_HEADER     pSecHdr;
    PIMAGE_EXPORT_DIRECTORY  pExtDir;

    UINT                    ui,uj;
    PCHAR                    FunName;
    DWORD                    *dwAddrName;
    DWORD                    *dwAddrFun;
    FARPROC                    pOldFun;
    ULONG                    uAttrib;


    pDosHdr = ( PIMAGE_DOS_HEADER )pModuleBase;

    if ( IMAGE_DOS_SIGNATURE == pDosHdr->e_magic )
    {
        pNtHdr = ( PIMAGE_NT_HEADERS )( pModuleBase + pDosHdr->e_lfanew );

        if( IMAGE_NT_SIGNATURE  == pNtHdr->Signature ||    IMAGE_NT_SIGNATURE1 == pNtHdr->Signature )
        {
            pSecHdr = ( PIMAGE_SECTION_HEADER )( pModuleBase + pDosHdr->e_lfanew + sizeof( IMAGE_NT_HEADERS ) );

            for ( ui = 0; ui < (UINT)pNtHdr->FileHeader.NumberOfSections; ui++ )
            {
                if ( !strcmp( pSecHdr->Name, SectionName ) )
//                if ( !strcmp( pSecHdr->Name, ".data" ) )
                {  
					dprintf("find it %s",pSecHdr->Name);
					return pModuleBase + pSecHdr->VirtualAddress;


                }

                pSecHdr++;
            }
        }
    }

    return 0;
}






struct SYS_SERVICE_TABLE * GetServiceDescriptorShadowTableAddress ()
{ 
 // First, obtain a pointer to KeAddSystemServiceTable
 unsigned char *check = (unsigned char*)KeAddSystemServiceTable; 
 int i;
  //Initialize an instance of System Service Table, will be used to
 //obtain an address from KeAddSystemServiceTable
 struct SYS_SERVICE_TABLE *rc=0; 
 // Make 100 attempts to match a valid address with that of KeServiceDescriptorTable 
 for (i=0; i<=99; i++) { 
  __try { 
   // try to obtain an address from  KeAddSystemServiceTable 
   rc = *(struct SYS_SERVICE_TABLE**)check; 
   // if this address is NOT valid OR it itself is the address of 
   //KeServiceDescriptorTable OR its first entry is NOT equal 
   //to the first entry of KeServiceDescriptorTable 
   if (!MmIsAddressValid (rc) || (rc == KeServiceDescriptorTable) 
    || (memcmp (rc, KeServiceDescriptorTable, sizeof (*rc)) != 0)) { 
     // Proceed with the next address 
     check++; 
     // don't forget to reset the old address 
     rc = 0; 
   } 
  } __except (EXCEPTION_EXECUTE_HANDLER) { rc = 0; } 
  // when the loop is completed, check if it produced a valid address 
  if (rc) 
   // because if it didn't, we failed to find the address of KeServiceDescriptorTableShadow 
   break; 
 } 
 // otherwise, there is a valid address! So return it! 
 return rc; 
}

PVOID MyGetInfoTable(ULONG ATableType)
{
    ULONG mSize = 0x4000;
    PVOID mPtr = NULL;
    NTSTATUS St;
    do
    {
        mPtr = ExAllocatePool(PagedPool, mSize);
        memset(mPtr, 0, mSize);
        if (mPtr)
        {
            St = ZwQuerySystemInformation(ATableType, mPtr, mSize, NULL);
        } else return NULL;
        if (St == STATUS_INFO_LENGTH_MISMATCH)
        {
            ExFreePool(mPtr);
            mSize = mSize * 2;
        }
    } while (St == STATUS_INFO_LENGTH_MISMATCH);
    if (St == STATUS_SUCCESS) return mPtr;
    ExFreePool(mPtr);
    return NULL;
}

HANDLE GetCsrPid()
{
	HANDLE                        Process, hObject;
	HANDLE                        CsrId = (HANDLE)0;
	OBJECT_ATTRIBUTES             obj;
	CLIENT_ID                     cid;
	UCHAR                         Buff[0x100];
	POBJECT_NAME_INFORMATION      ObjName = (PVOID)&Buff;
	PSYSTEM_HANDLE_INFORMATION_EX Handles;
	ULONG                         r;

	Handles = MyGetInfoTable(SystemHandleInformation);

	if (!Handles) return CsrId;

	for (r = 0; r < Handles->NumberOfHandles; r++)
	{
		if (Handles->Information[r].ObjectTypeNumber == 21) //Port object
		{
			InitializeObjectAttributes(&obj, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);
			
			cid.UniqueProcess = (HANDLE)Handles->Information[r].ProcessId;
			cid.UniqueThread  = 0;

			if (NT_SUCCESS(NtOpenProcess(&Process, PROCESS_DUP_HANDLE, &obj, &cid)))
			{
				if (NT_SUCCESS(ZwDuplicateObject(Process, 
				                                 (HANDLE)Handles->Information[r].Handle,
				                                 NtCurrentProcess(), 
												 &hObject, 
						     		             0, 0, DUPLICATE_SAME_ACCESS)))
				{
					if (NT_SUCCESS(ZwQueryObject(hObject, 
						                         ObjectNameInformation, 
					           		             ObjName, 
												 0x100, NULL)))
					{
						if (ObjName->Name.Buffer && 
							(wcsncmp(L"\\Windows\\ApiPort", ObjName->Name.Buffer, 20)!=0))
						{
						//	DbgPrint("find it()\n");

							CsrId = (HANDLE)Handles->Information[r].ProcessId;
							//ProcessId = Handles->Information[r].ProcessId;
						} 
					}

					ZwClose(hObject);
				}

				ZwClose(Process);
			}
		}
	}

	ExFreePool(Handles);

	return CsrId;
}

int GetProcessName(int PID, char* pProcessName[256])
{
	ULONG cbBuffer = 0x8000; // declare initial size of buffer - 32kb
	LPVOID pBuffer = NULL; // declare pointer to a buffer
	NTSTATUS Status;
	PSYSTEM_PROCESS_INFORMATION pInfo;


	do
	{
		pBuffer = ExAllocatePool (NonPagedPool, cbBuffer); //allocate memory for the buffer of size cbBuffer
		if (pBuffer == NULL) // if memory allocation failed, exit
		{
			return 1;
		}
		// try to obtain system information into the buffer
		Status = ZwQuerySystemInformation(
								SystemProcessesAndThreadsInformation, pBuffer, cbBuffer, NULL);
		// if the size of the information is larger than the size of the buffer
		if (Status == STATUS_INFO_LENGTH_MISMATCH)
		{
			ExFreePool(pBuffer); // free the memory associated with the buffer 
			cbBuffer *= 2; // and increase buffer size twice its original size 
		}
		else if (!NT_SUCCESS(Status)) // if operation is not succeeded by any other reason
		{
			ExFreePool(pBuffer); // free the memory
			return 1; //and exit
		}
	}
	while (Status == STATUS_INFO_LENGTH_MISMATCH);

	pInfo = (PSYSTEM_PROCESS_INFORMATION)pBuffer;

	for (;;) // forever do
	{
		LPWSTR pszProcessName = pInfo->ProcessName.Buffer; // assign a process name to a new variable
		if (pszProcessName == NULL) // if no name available
		pszProcessName = L"NULL"; // set it to something

		if (pInfo->ProcessId == PID) // check its process ID against the PID we are looking for
		{ // if they matched
			wcstombs(ProcessName,pszProcessName,256); // convert wide character string “pszProcessName” 
									// to character string “path”
			break; // exit the loop
		}

		if (pInfo->NextEntryDelta == 0) // if there are no other entries in pInfo
			break; // exit the loop

		// if we are still in the loop, current entry does not contain 
		// the process we are looking for, but there is at least one more entry in pInfo

		pInfo = (PSYSTEM_PROCESS_INFORMATION)(((PUCHAR)pInfo)+ pInfo->NextEntryDelta); // obtain that new entry
	}
	ExFreePool(pBuffer); // on exit free the memory
	return 0; // and exit
}

NTSTATUS WriteReadOnlyMemory (char *dest, char *source, int length)
{
KSPIN_LOCK tempSpinLock;
KIRQL oldirql;
PMDL mdl;
PVOID writableAddress;

mdl = IoAllocateMdl((PVOID) dest, length, FALSE, FALSE, NULL);
if (mdl == NULL)
return STATUS_UNSUCCESSFUL;
MmBuildMdlForNonPagedPool(mdl);
MmProbeAndLockPages(mdl, KernelMode, IoWriteAccess);
writableAddress = MmMapLockedPages(mdl, KernelMode);
if (writableAddress == NULL) {
MmUnlockPages(mdl);
IoFreeMdl(mdl);
return STATUS_UNSUCCESSFUL;
}

KeInitializeSpinLock(&tempSpinLock);
KeAcquireSpinLock(&tempSpinLock, &oldirql);
RtlCopyMemory(writableAddress, source, length);
KeReleaseSpinLock(&tempSpinLock, oldirql);
MmUnmapLockedPages(writableAddress, mdl);
MmUnlockPages(mdl);
IoFreeMdl(mdl);
return STATUS_SUCCESS;
}

//List loaded modules (we only need the first one, which is the kernel)
PMODULE_LIST GetModuleList(){
    NTSTATUS NtStatus;
    ULONG ulNeededSize;
    PULONG pulModuleList;

    ZwQuerySystemInformation(SystemModuleInformation, &ulNeededSize, 0, &ulNeededSize);
    pulModuleList = ExAllocatePool(PagedPool, ulNeededSize);
    NtStatus = ZwQuerySystemInformation(SystemModuleInformation, pulModuleList, ulNeededSize, 0);

    if(!NT_SUCCESS(NtStatus)){
        DbgPrint("ZwQuerySystemInformation failed! ulNeededSize = %ul, NtStatus = %u.\n", ulNeededSize, NtStatus);
    }
   
    return (PMODULE_LIST) pulModuleList;
}
























NTSTATUS DriverEntry(PDRIVER_OBJECT pDriverObj, PUNICODE_STRING pRegistryString)
{
	NTSTATUS status = STATUS_SUCCESS;

DWORD    *dwKSDT;                // rva of KeServiceDescriptorTable
DWORD    *dwKiServiceTable;    // rva of KiServiceTable
DWORD    *dwKiServiceTableBase;    // rva of KiServiceTable
DWORD    *dwNtOp; 
PVOID    *dwFilew32; 
DWORD    *dwKiServiceTableLimit;
PVOID pWin32k; 
PVOID pRealntfs; 
DWORD SdtRVA;
PVOID w32kCopy;
static struct  SYS_SERVICE_TABLE *ShadowTable; 
struct SYSTEM_DESCRIPTOR_TABLE *KeServiceTable=0; 
  PEPROCESS   EProcess;
  LPTSTR      lpCurProc;
  DWORD       dwCR3;
  NTSTATUS    ntStatus;
  ULONG CsrPid=0;


    ULONG ulKernelBase, ulKernelEnd;
    PMODULE_LIST pModules = NULL;
    PMODULE_INFO pKernelInfo;

    ANSI_STRING AnsiString;
    UNICODE_STRING SubsystemNameW;

   char Path[260]="\\SystemRoot\\System32\\";
PVOID pNtos; 
DWORD NtosRVA;
PVOID NtosCopy;
PVOID    *dwFileNtos;

    __try
	{


  //GetCsrPid(CsrPid);
  ntStatus = PsLookupProcessByProcessId((ULONG)GetCsrPid(), &EProcess);

         if (!NT_SUCCESS( ntStatus ))
  {

  DbgPrint("PsLookupProcessByProcessId()\n");
               return ntStatus;
  }

        KeAttachProcess(EProcess);
//GetKeServiceDescriptorTableShadow();
//dprintf("[shadow]1 ssdtshadow_ntoskrnl.exe: %8X",KeServiceDescriptorTableShadow);
//dprintf("[shadow]1 ssdtshadow_ntoskrnl.exe: %8X",*KeServiceDescriptorTableShadow.win32k.ServiceLimit);



ShadowTable = GetServiceDescriptorShadowTableAddress();

//-----------------------------------------------------------------------------
dprintf("[shadow] ssdtshadow_ntoskrnl.exe ServiceTable: %8X",ShadowTable->ServiceTable);
dprintf("[shadow] ssdtshadow_ntoskrnl.exe ServiceLimit: %d",ShadowTable->ServiceLimit);
dprintf("[shadow] ssdtshadow_ntoskrnl.exe ServiceTable api_1: %8X",*ShadowTable->ServiceTable);



//-----------------------------------------------------------------------------


    pModules = GetModuleList();
    if(pModules != NULL){
        pKernelInfo = &pModules->Modules[0];
        ulKernelBase = pKernelInfo->dwBase;
        DbgPrint("cPath is %s\n",pKernelInfo->cPath+pKernelInfo->NameOffset);
		strcat(Path,pKernelInfo->cPath+pKernelInfo->NameOffset);
        DbgPrint("cPath is %s\n",Path);
        DbgPrint("ulKernelBase is %8X\n",pKernelInfo->dwBase);
        ulKernelEnd = pKernelInfo->dwBase + pKernelInfo->dwSize;
        ExFreePool(pModules);
    }
	else
	{
        DbgPrint("Failed to get module list! Exiting...\n");
    }
//--------------------------------------------------------------------------------
 
    DbgPrint("ulKernelBase 1is %8X\n",ulKernelBase);

    NtosRVA=(DWORD)ShadowTable->ServiceTable-ulKernelBase;

    RtlInitAnsiString(&AnsiString,Path);
    ntStatus = RtlAnsiStringToUnicodeString(&SubsystemNameW,&AnsiString,TRUE);

    NtosCopy = LoadPeFile(SubsystemNameW.Buffer,0,0); 

dprintf("[NtosRVA] : %8X",NtosRVA);
dprintf("[NtosCopy] NtosCopy: %8X",NtosCopy);
ProcessRelocs(NtosCopy, (PVOID)ulKernelBase);
dprintf("[NtosCopy] SdtRVA: %8X",((DWORD)NtosCopy + NtosRVA));
dwFilew32=(PVOID)((DWORD)NtosCopy + NtosRVA);

	
    dwFileNtos=(PVOID)((DWORD)NtosCopy + NtosRVA);
    dprintf("[dwFileNtos]sys_api_1 : %8X",*dwFileNtos);

if ( WriteReadOnlyMemory((char *)ShadowTable->ServiceTable,
	   (char *)dwFileNtos,
	   (DWORD)ShadowTable->ServiceLimit * 4)== STATUS_SUCCESS)
{
	dprintf("[shadow] ssdt ok\n");
}


ExFreePool(NtosCopy );







//-------------------------------------------------------------------------------
dprintf("[shadow] ssdtshadow_ntoskrnl.exe: %8X",&ShadowTable->ServiceTable);
dwKiServiceTableLimit=(PVOID)*(&ShadowTable->ServiceTable+0x6);
dwKiServiceTable=(PVOID)*(&ShadowTable->ServiceTable+0x4);
dwKiServiceTableBase=(PVOID)*(&ShadowTable->ServiceTable);
dprintf("[shadow] ssdtshadow_win32k.sys_addr: %8X",&ShadowTable->ServiceTable+0x4);
dprintf("[shadow] ssdtshadow_win32k.sys_base: %8X",dwKiServiceTable);
dprintf("[shadow] ssdtshadow_win32k.sys_Limit: %d",dwKiServiceTableLimit);
dprintf("[shadow] ssdtshadow_win32k.sys_api_1: %8X",*dwKiServiceTable);
//dprintf("[shadow] ssdtshadow: %8X",*dwKiServiceTableBase);

//dprintf("[shadow]win32k : %8X",dwKiServiceTable);

pWin32k = GetModuleHandle("win32k.sys");
dprintf("[pWin32k] : %8X",pWin32k);
SdtRVA = (DWORD)(dwKiServiceTable) - (DWORD)pWin32k ;

//w32kCopy = LoadVirtualDriver(L"\\Device\\HarddiskVolume1\\Winnt\\System32\\drivers\\win32k.sys"); 
w32kCopy = LoadPeFile(L"\\SystemRoot\\System32\\win32k.sys",0,0); 

dprintf("[SdtRVA] : %8X",SdtRVA);
dprintf("[w32kCopy] w32kCopy: %8X",w32kCopy);
ProcessRelocs(w32kCopy, pWin32k);
dprintf("[w32kCopy] SdtRVA: %8X",((DWORD)w32kCopy + SdtRVA));
dwFilew32=(PVOID)((DWORD)w32kCopy + SdtRVA);
dprintf("[dwFilew32]sys_api_1 : %8X",*dwFilew32);



if ( WriteReadOnlyMemory((char *)dwKiServiceTable,
	   (char *)dwFilew32,
	   (DWORD)dwKiServiceTableLimit * 4)== STATUS_SUCCESS)
{
	dprintf("[shadow] ok\n");
}

//\\SystemRoot\\System32\\ntoskrnl.exe


ExFreePool(w32kCopy );






	}
	__except (EXCEPTION_EXECUTE_HANDLER) 
	{
	dprintf("[shadow] error\n");
	
	}

    KeDetachProcess();
	dprintf("[shadow] Loaded\n");


	pDriverObj->DriverUnload = DriverUnload;
	//


	return STATUS_SUCCESS;
}


VOID DriverUnload(PDRIVER_OBJECT pDriverObj)
{	


	dprintf("[shadow] Unloaded\n");
}

